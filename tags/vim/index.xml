<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mr.Proger</title><link>https://konkin-ivan.github.io/tags/vim/</link><description>Описание моего блога</description><generator>Hugo</generator><language>ru-ru</language><lastBuildDate>Sat, 27 Sep 2025 08:14:19 +0000</lastBuildDate><atom:link href="https://konkin-ivan.github.io/tags/vim/" rel="self" type="application/rss+xml"/><item><title>Библиотека для трейдинга: начало</title><link>https://konkin-ivan.github.io/posts/taljure-0/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0000</pubDate><author/><guid>https://konkin-ivan.github.io/posts/taljure-0/</guid><description>Этим и начинаю цикл статей, в котором с чистого листа буду разрабатывать open-source библиотеку для алгоритмического трейдинга.</description><content type="html">&lt;h1 id="библиотека-для-трейдинга-начало">Библиотека для трейдинга: начало&lt;/h1>
&lt;h2 id="запуск-open-source-проекта-clojure-библиотека-для-алготрейдинга-с-нуля">Запуск Open-Source проекта: Clojure библиотека для алготрейдинга с нуля&lt;/h2>
&lt;p>&lt;img src="https://konkin-ivan.github.io/images/posts/taljure/taljure-0.png" alt="Запуск open-source taljure">&lt;/p>
&lt;p>Запуск open-source taljure&lt;/p>
&lt;p>Этим и начинаю цикл статей, в котором с чистого листа буду разрабатывать open-source библиотеку для алгоритмического трейдинга. Цель — создать инструмент, который будет максимально кложур-френдли, прозрачным в работе и полезным как для изучения основ алготрейдинга, так и для использования в более серьезных проектах.&lt;/p>
&lt;h3 id="зачем-это-нужно">Зачем это нужно?&lt;/h3>
&lt;p>Существует множество готовых решений, но они часто представляют собой обертки над ta-lib, написанным на C++. Мне же хотелось создать что-то на Clojure — языке, где мощь в обработке данных и многопоточности идеально подходит для финансовых вычислений. Я хочу:&lt;/p>
&lt;p>Глубже разобраться в индикаторах: Не просто использовать ta-lib, а понять, как работают SMA, EMA, RSI и другие метрики «под капотом».&lt;/p>
&lt;p>Сделать Clojure-way библиотеку: Иммутабельные данные, чистые функции, последовательности — все это идеально ложится на концепцию обработки временных рядов.&lt;/p>
&lt;p>Предложить альтернативу: Сообществу трейдеров-разработчиков, интересующихся Clojure, не хватает своих, идиоматических инструментов.&lt;/p>
&lt;h3 id="технический-стек-и-философия">Технический стек и философия&lt;/h3>
&lt;p>Проект будет строго придерживаться принципов простоты и прозрачности:&lt;/p>
&lt;p>Чистый Clojure: Никаких фреймворков. Только язык и его стандартная библиотека.&lt;/p>
&lt;p>Docker-окружение: Чтобы у любого желающего не возникло проблем с запуском, вся разработка будет вестись в изолированном контейнере. deps.edn + docker-compose — наш выбор.&lt;/p>
&lt;p>Тесты с первого дня: Каждый индикатор будет покрыт тестами, чтобы можно было быть уверенным в корректности расчетов.&lt;/p>
&lt;p>Промышленный подход: Библиотека с первого дня будет оформлена как настоящий open-source проект: с качественным README, документацией, лицензией и примерами использования.&lt;/p>
&lt;h3 id="о-чем-будем-говорить-в-следующих-статьях">О чем будем говорить в следующих статьях&lt;/h3>
&lt;p>В этом посте я лишь намечаю контуры проекта. В следующих выпусках мы детально разберем каждый этап:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>настроим идеальное окружение для Clojure-разработки с помощью Docker;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>разберем deps.edn: какие зависимости нам понадобятся и зачем;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>напишем свои первые индикаторы (SMA, EMA) и тесты к ним;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>сравним наши расчеты с эталонными реализациями;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>собирем библиотеку и пробуем подключить ее к «боевому» проекту;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>документируем код и публикуем первую версию на Clojars.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Этот проект — эксперимент и образовательный путь. Приглашаю всех заинтересованных присоединиться: следить за циклом статей, предлагать идеи или даже контрибьютить в репозитории.&lt;/p>
&lt;p>Исходный код будет доступен на &lt;a href="https://gitflic.ru/project/konkin/taljure">GitFlic&lt;/a> (можно участвовать).&lt;/p>
&lt;p>Что вы думаете о такой идее? Какие индикаторы или функционал вам было бы интересно увидеть в первую очередь? Делитесь мыслями в комментариях!&lt;/p></content></item><item><title>Код как живой организм: от говнокода к архитектуре</title><link>https://konkin-ivan.github.io/posts/shitcode/</link><pubDate>Wed, 06 Aug 2025 00:00:00 +0000</pubDate><author/><guid>https://konkin-ivan.github.io/posts/shitcode/</guid><description>Когда я только начинал программировать, мне казалось, что хороший код должен выглядеть идеально с первой строчки:</description><content type="html">&lt;h1 id="код-как-живой-организм-от-говнокода-к-архитектуре">Код как живой организм: от говнокода к архитектуре&lt;/h1>
&lt;h3 id="как-страх-плохого-кода-мешает-развиваться">&lt;strong>Как страх «плохого кода» мешает развиваться&lt;/strong>&lt;/h3>
&lt;p>Когда я только начинал программировать, мне казалось, что хороший код должен выглядеть идеально с первой строчки:&lt;/p>
&lt;ul>
&lt;li>Чистые функции,&lt;/li>
&lt;li>Правильные паттерны,&lt;/li>
&lt;li>Идеальная архитектура&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>Я боялся браться за задачи, потому что думал:&lt;br>
&lt;em>«А вдруг сделаю не по SOLID? А если нарушу DRY? А если опытные разработчики увидят мой код и назовут его говнокодом?»&lt;/em>&lt;/p>
&lt;p>Результат? &lt;strong>Паралич&lt;/strong>. Вместо кода — пустой файл, бесконечные раздумья и ноль результата.&lt;/p>
&lt;p>Пока не осознал простую вещь:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Код — как живой организм. Он рождается слабым, обрастает мускулами и только потом становится сильным.&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>И это нормально.&lt;/p>
&lt;hr>
&lt;h3 id="почему-первый-код--это-почти-всегда-говнокод-и-это-не-плохо">&lt;strong>Почему первый код — это почти всегда «говнокод» (и это не плохо)&lt;/strong>&lt;/h3>
&lt;h4 id="working-solution--perfect-architecture">&lt;strong>Working solution &amp;gt; Perfect architecture&lt;/strong>&lt;/h4>
&lt;p>Твоя задача — не написать шедевр, а &lt;strong>решить проблему&lt;/strong>.&lt;/p>
&lt;h4 id="пример-функция-на-clojure">&lt;strong>Пример: функция на Clojure&lt;/strong>&lt;/h4>
&lt;p>Допустим, нам нужно отфильтровать список чисел, оставив только чётные.&lt;/p>
&lt;p>&lt;strong>Первый вариант (наивный, «говнокод»):&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>filter-even [numbers]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">loop &lt;/span>[nums numbers result []]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&lt;span style="color:#a6e22e">empty?&lt;/span> nums)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>[num (first nums)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&lt;span style="color:#a6e22e">even?&lt;/span> num)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">recur&lt;/span> (rest nums) (conj result num))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">recur&lt;/span> (rest nums) result)))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>Что не так?&lt;/em>&lt;/p>
&lt;ul>
&lt;li>Громоздкий &lt;code>loop/recur&lt;/code>, хотя в Clojure есть &lt;code>filter&lt;/code>.&lt;/li>
&lt;li>Избыточность, ручное управление состоянием.&lt;/li>
&lt;/ul>
&lt;p>Но &lt;strong>это работает!&lt;/strong> И это главное.&lt;/p>
&lt;hr>
&lt;h3 id="3-эволюция-кода-как-хаос-превращается-в-порядок">&lt;strong>3. Эволюция кода: как хаос превращается в порядок&lt;/strong>&lt;/h3>
&lt;p>Теперь, когда есть работающее решение, можно его улучшать.&lt;/p>
&lt;h4 id="рефакторинг-1-используем-filter">&lt;strong>Рефакторинг #1: используем &lt;code>filter&lt;/code>&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>filter-even [numbers]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (filter even? numbers))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Уже лучше! Но что, если нужно ещё и удвоить чётные числа?&lt;/p>
&lt;h4 id="рефакторинг-2-добавляем-map">&lt;strong>Рефакторинг #2: добавляем &lt;code>map&lt;/code>&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>process-numbers [numbers]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">-&amp;gt;&amp;gt;&lt;/span> numbers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (filter even?)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map &lt;span style="color:#f92672">#&lt;/span>(* % &lt;span style="color:#ae81ff">2&lt;/span>))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Теперь код:&lt;/p>
&lt;ul>
&lt;li>Лаконичный,&lt;/li>
&lt;li>Читаемый,&lt;/li>
&lt;li>Расширяемый.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Что изменилось?&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Мы &lt;strong>не планировали&lt;/strong> эту архитектуру заранее.&lt;/li>
&lt;li>Она &lt;strong>появилась естественно&lt;/strong>, когда потребовалось добавить новую логику.&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="4-почему-паттерны-и-solid--это-результат-а-не-старт">&lt;strong>4. Почему паттерны и SOLID — это результат, а не старт&lt;/strong>&lt;/h3>
&lt;p>Многие думают, что нужно &lt;strong>сначала выучить все принципы&lt;/strong>, а потом писать код.&lt;/p>
&lt;p>Но на практике:&lt;/p>
&lt;ul>
&lt;li>Ты пишешь &lt;strong>как получается&lt;/strong>,&lt;/li>
&lt;li>Сталкиваешься с проблемами,&lt;/li>
&lt;li>И только потом &lt;strong>осознаёшь&lt;/strong>, что твой код — это, например, &lt;em>Стратегия&lt;/em> или &lt;em>Фабрика&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h4 id="пример-случайный-паттерн">&lt;strong>Пример: «случайный» паттерн&lt;/strong>&lt;/h4>
&lt;p>Допустим, у нас есть:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>save-data [data storage-type]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">cond&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (= storage-type &lt;span style="color:#e6db74">:db&lt;/span>) (&lt;span style="color:#a6e22e">save-to-db&lt;/span> data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (= storage-type &lt;span style="color:#e6db74">:file&lt;/span>) (&lt;span style="color:#a6e22e">save-to-file&lt;/span> data)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="какие-проблемы-возникают">&lt;strong>Какие проблемы возникают?&lt;/strong>&lt;/h3>
&lt;h4 id="1-трудно-масштабировать">&lt;strong>1. Трудно масштабировать&lt;/strong>&lt;/h4>
&lt;p>Допустим, появился новый тип хранилища — &lt;code>:s3&lt;/code>. Теперь нужно:&lt;/p>
&lt;ul>
&lt;li>Лезть в исходную функцию.&lt;/li>
&lt;li>Добавлять новую ветку &lt;code>cond&lt;/code>.&lt;/li>
&lt;li>Рисковать сломать существующую логику.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Проблема&lt;/strong>: Нарушение &lt;strong>Open-Closed Principle&lt;/strong> (код открыт для изменений, но закрыт для модификаций).&lt;/p>
&lt;h4 id="2-жёсткая-связанность">&lt;strong>2. Жёсткая связанность&lt;/strong>&lt;/h4>
&lt;p>Функция &lt;code>save-data&lt;/code> явно зависит от:&lt;/p>
&lt;ul>
&lt;li>Конкретных ключей (&lt;code>:db&lt;/code>, &lt;code>:file&lt;/code>).&lt;/li>
&lt;li>Конкретных функций (&lt;code>save-to-db&lt;/code>, &lt;code>save-to-file&lt;/code>).&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Что если&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Ключи поменяются?&lt;/li>
&lt;li>Нужно будет добавить валидацию &lt;code>data&lt;/code> перед сохранением?&lt;/li>
&lt;/ul>
&lt;h4 id="сложно-тестировать">&lt;strong>Сложно тестировать&lt;/strong>&lt;/h4>
&lt;p>Чтобы протестировать &lt;code>save-data&lt;/code>, нужно:&lt;/p>
&lt;ul>
&lt;li>Мокать &lt;code>save-to-db&lt;/code> и &lt;code>save-to-file&lt;/code>.&lt;/li>
&lt;li>Контролировать все ветки &lt;code>cond&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Позже мы понимаем, что это &lt;strong>Strategy&lt;/strong> — и выносим логику в отдельные функции:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defmulti &lt;/span>save-data (&lt;span style="color:#66d9ef">fn &lt;/span>[data storage-type] storage-type))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defmethod &lt;/span>save-data &lt;span style="color:#e6db74">:db&lt;/span> [data _] (&lt;span style="color:#a6e22e">save-to-db&lt;/span> data))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defmethod &lt;/span>save-data &lt;span style="color:#e6db74">:file&lt;/span> [data _] (&lt;span style="color:#a6e22e">save-to-file&lt;/span> data))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="как-прийти-к-этому-решению-на-практике">&lt;strong>Как прийти к этому решению на практике?&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Сначала&lt;/strong> пишем «лобовой» код через &lt;code>cond&lt;/code>/&lt;code>case&lt;/code> (это нормально!).&lt;/li>
&lt;li>&lt;strong>Замечаем&lt;/strong>, что веток становится слишком много.&lt;/li>
&lt;li>&lt;strong>Рефакторим&lt;/strong>, когда:&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Появляется новый тип хранилища.&lt;/li>
&lt;li>Начинаются проблемы с тестами.&lt;/li>
&lt;li>Код становится неподдерживаемым.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Задача&lt;/strong>&lt;/p>
&lt;p>Есть список пользователей, и нужно:&lt;/p>
&lt;ol>
&lt;li>Отфильтровать только активных (&lt;code>:active? true&lt;/code>).&lt;/li>
&lt;li>Оставить их имена.&lt;/li>
&lt;li>Отсортировать по алфавиту.&lt;/li>
&lt;/ol>
&lt;h3 id="1-первая-мысль-сделаю-через-циклы-потому-что-это-очевидно">&lt;strong>1. Первая мысль: «Сделаю через циклы!» (потому что это «очевидно»)&lt;/strong>&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>get-active-usernames [users]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>[active-users (&lt;span style="color:#66d9ef">loop &lt;/span>[users users result []]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&lt;span style="color:#a6e22e">empty?&lt;/span> users)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>[user (first users)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&lt;span style="color:#e6db74">:active?&lt;/span> user)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">recur&lt;/span> (rest users) (conj result user))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">recur&lt;/span> (rest users) result)))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> usernames (&lt;span style="color:#66d9ef">loop &lt;/span>[users active-users result []]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">if &lt;/span>(&lt;span style="color:#a6e22e">empty?&lt;/span> users)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">recur&lt;/span> (rest users) (conj result (&lt;span style="color:#e6db74">:name&lt;/span> (first users))))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted-names (sort usernames)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted-names))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Почему так происходит?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Мозг сразу тянется к &lt;strong>императивному подходу&lt;/strong> («перебрать, проверить, собрать»).&lt;/li>
&lt;li>Страх перед «неизвестными» функциями (&lt;code>filter&lt;/code>, &lt;code>map&lt;/code>, &lt;code>comp&lt;/code>).&lt;/li>
&lt;li>Кажется, что «так надёжнее» (хотя код превращается в лапшу).&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-момент-осознания-а-ведь-это-можно-упростить">&lt;strong>2. Момент осознания: «А ведь это можно упростить…»&lt;/strong>&lt;/h3>
&lt;p>После того как код работает, появляется мысль:&lt;br>
&lt;em>«Наверное, есть способ лучше»&lt;/em> → гуглим/спрашиваем/экспериментируем.&lt;/p>
&lt;p>&lt;strong>Рефакторинг: шаг за шагом&lt;/strong>&lt;/p>
&lt;h4 id="шаг-1-замена-ручного-фильтра-на-filter">&lt;strong>Шаг 1. Замена ручного фильтра на &lt;code>filter&lt;/code>&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>get-active-usernames [users]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">let &lt;/span>[active-users (filter &lt;span style="color:#e6db74">:active?&lt;/span> users) &lt;span style="color:#75715e">; &amp;lt;- магия keyword как предиката!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> usernames (map &lt;span style="color:#e6db74">:name&lt;/span> active-users)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted-names (sort usernames)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted-names))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="шаг-2-убираем-промежуточные-переменные">&lt;strong>Шаг 2. Убираем промежуточные переменные&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>get-active-usernames [users]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (sort (map &lt;span style="color:#e6db74">:name&lt;/span> (filter &lt;span style="color:#e6db74">:active?&lt;/span> users))))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="шаг-3-тред-ласт-макрос---для-читаемости">&lt;strong>Шаг 3. Тред-ласт макрос (&lt;code>-&amp;gt;&amp;gt;&lt;/code>) для читаемости&lt;/strong>&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">defn &lt;/span>get-active-usernames [users]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">-&amp;gt;&amp;gt;&lt;/span> users
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (filter &lt;span style="color:#e6db74">:active?&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (map &lt;span style="color:#e6db74">:name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">sort&lt;/span>)))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="психологический-подтекст">&lt;strong>Психологический подтекст&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Страх «незнания»&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Сначала кажется, что &lt;code>loop/recur&lt;/code> — это «безопасно», потому что понятно.&lt;/li>
&lt;li>Функции высшего порядка (&lt;code>filter&lt;/code>, &lt;code>map&lt;/code>) требуют &lt;strong>доверия&lt;/strong> к языку.&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>&lt;strong>Эффект «Я это сделал!»&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>После рабочего, но громоздкого кода, приходит &lt;strong>облегчение&lt;/strong>.&lt;/li>
&lt;li>Теперь можно &lt;strong>сфокусироваться на улучшениях&lt;/strong> (а не на панике).&lt;/li>
&lt;/ul>
&lt;ol start="5">
&lt;li>&lt;strong>Архитектура через рефакторинг&lt;/strong>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Изначально ты не задумываешься о «чистоте» — просто решал задачу.&lt;/li>
&lt;li>Но после рефакторинга код &lt;strong>сам стал похож на паттерн&lt;/strong> (например, &lt;em>Pipeline&lt;/em>).&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="индустрия-программирования-создаёт-токсичный-перфекционизм">&lt;strong>Индустрия программирования создаёт токсичный перфекционизм&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>Курсы, собеседования, статьи&lt;/strong> — все твердят:&lt;/p>
&lt;ul>
&lt;li>«SOLID, паттерны, чистый код!»&lt;/li>
&lt;li>«Если не знаешь DRY/KISS/YAGNI — ты не разработчик!»&lt;/li>
&lt;li>«Архитектура должна быть идеальной с первого коммита».&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Результат?&lt;/strong>&lt;br>
Новички (и даже мидлы) впадают в &lt;strong>паралич анализа&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>«Вдруг я сделаю не по стандартам?»&lt;/li>
&lt;li>«А что если мой код назовут говнокодом?»&lt;/li>
&lt;li>«Я не понимаю, как применить Factory Method здесь… Может, не браться за задачу?»&lt;/li>
&lt;/ul>
&lt;p>Но правда в том, что:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Лучшие практики — это выводы, а не входные данные.&lt;/strong>&lt;br>
Их нельзя «выучить». Их можно только &lt;strong>прочувствовать через боль&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h3 id="почему-быстрый-говнокод--это-не-стыдно-а-необходимо">&lt;strong>Почему «быстрый говнокод» — это не стыдно, а необходимо&lt;/strong>&lt;/h3>
&lt;h4 id="пример-из-жизни">&lt;strong>Пример из жизни&lt;/strong>&lt;/h4>
&lt;p>Представь, что ты учишься играть на гитаре:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Теория:&lt;/strong> «Вот 100 аккордов, вот 20 гамм, играй как Хендрикс».&lt;/li>
&lt;li>&lt;strong>Реальность:&lt;/strong> Сначала ты бренчишь &lt;em>«Кузнечика»&lt;/em> на трёх аккордах — и это нормально.&lt;/li>
&lt;/ul>
&lt;p>То же с кодом. &lt;strong>Алгоритм эффективного обучения:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Накидал прототип&lt;/strong> (пусть криво, но работает).&lt;/li>
&lt;li>&lt;strong>Понял задачу&lt;/strong> (ага, вот где подводные камни).&lt;/li>
&lt;li>&lt;strong>Улучшил&lt;/strong> (рефакторинг, паттерны, оптимизация).&lt;/li>
&lt;/ol>
&lt;h4 id="почему-clojur-разработчикам-тут-повезло">&lt;strong>Почему Clojur-разработчикам тут повезло&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>ФП + иммутабельность&lt;/strong> = меньше последствий от хаотичного прототипирования.&lt;/li>
&lt;li>&lt;strong>REPL&lt;/strong> = моментальная проверка гипотез без «перезапуска проекта».&lt;/li>
&lt;li>&lt;strong>Парадигма «данные &amp;gt; функции»&lt;/strong> = легко пересобирать логику.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-как-бороться-со-страхом-неидеального-кода">&lt;strong>3. Как бороться со страхом «неидеального кода»&lt;/strong>&lt;/h3>
&lt;h4 id="принять-первый-код-почти-всегда-плох">&lt;strong>Принять: первый код почти всегда плох&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Linus Torvalds&lt;/strong> не написал Git «с нуля идеальным».&lt;/li>
&lt;li>&lt;strong>Rich Hickey&lt;/strong> до Clojure делал десятки прототипов.&lt;/li>
&lt;/ul>
&lt;p>Твой код — &lt;strong>черновик&lt;/strong>, а не высеченный в мраморе памятник.&lt;/p>
&lt;h4 id="отделяй-эксперимент-от-продакшна">&lt;strong>Отделяй «эксперимент» от «продакшна»&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>Создайте ветку &lt;code>shitcode-prototype&lt;/code>.&lt;/li>
&lt;li>Пиши в ней &lt;strong>как угодно&lt;/strong>, чтобы проверить гипотезу.&lt;/li>
&lt;li>Если идея сработала — &lt;strong>тогда&lt;/strong> рефакторь.&lt;/li>
&lt;/ul>
&lt;h4 id="спрашивай-не-как-сделать-идеально-а-как-сделать-сейчас">&lt;strong>Спрашивай не «Как сделать идеально?», а «Как сделать сейчас?»&lt;/strong>&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>Плохо:&lt;/strong> «Я не знаю, как применить Command Pattern здесь…»&lt;/li>
&lt;li>&lt;strong>Хорошо:&lt;/strong> «Сначала сделаю через &lt;code>cond&lt;/code>, потом посмотрю, что можно улучшить».&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-что-говорят-практики">&lt;strong>4. Что говорят практики&lt;/strong>&lt;/h3>
&lt;h4 id="кен-бек-автор-tdd">&lt;strong>Кен Бек (автор TDD):&lt;/strong>&lt;/h4>
&lt;blockquote>
&lt;p>«Сначала сделайте так, чтобы оно работало. Затем сделайте правильно. И только потом — быстро».&lt;/p>
&lt;/blockquote>
&lt;h4 id="роберт-мартин-clean-code">&lt;strong>Роберт Мартин (Clean Code):&lt;/strong>&lt;/h4>
&lt;blockquote>
&lt;p>«Единственный способ написать чистый код — сначала написать грязный, а потом почистить его».&lt;/p>
&lt;/blockquote>
&lt;h4 id="clojure-разработчик-в-дикой-природе">&lt;strong>Clojure-разработчик в дикой природе:&lt;/strong>&lt;/h4>
&lt;blockquote>
&lt;p>«80% моего кода начинаются как &lt;code>(-&amp;gt;&amp;gt; data (map ...) (filter ...) (грубая агрегация))&lt;/code>.&lt;br>
А потом я удаляю половину и получаю хорошее решение».&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h3 id="вывод-принцип-сначала-практика-потом-теория">&lt;strong>Вывод: принцип «Сначала практика, потом теория»&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Курсы/книги&lt;/strong> учат «как должно быть», но не «как дойти до этого».&lt;/li>
&lt;li>&lt;strong>Твой опыт&lt;/strong> важнее чем мнение «экспертов».&lt;/li>
&lt;li>&lt;strong>Clojure&lt;/strong> — идеальный язык, чтобы &lt;strong>быстро ваять прототипы&lt;/strong> и &lt;strong>виртуозно рефакторить&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;strong>P.S.:&lt;/strong> Попробуй сегодня:&lt;/p>
&lt;ol>
&lt;li>Намеренно напиши &lt;strong>максимально «плохой» код&lt;/strong> для задачи.&lt;/li>
&lt;li>Заставь его работать.&lt;/li>
&lt;li>Затем &lt;strong>улучши&lt;/strong>.&lt;/li>
&lt;li>Почувствуй разницу!&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Вывод: кайфуй от процесса, а не гонись за идеалом&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Не бойся писать плохой код&lt;/strong> — это этап, а не приговор.&lt;/li>
&lt;li>&lt;strong>Архитектура рождается в процессе&lt;/strong> — а не в вакууме.&lt;/li>
&lt;li>&lt;strong>Паттерны — результат опыта&lt;/strong> — а не его условие.&lt;/li>
&lt;/ul>
&lt;p>Первый вариант кода — это не «плохо», это &lt;strong>исследование&lt;/strong>.&lt;br>
Мы не пишем архитектуру — мы её &lt;strong>открываем&lt;/strong> в процессе.&lt;br>
Сначала — работающий код. Потом — красивый. И только затем — «идеальный» (если он вообще нужен).&lt;/p>
&lt;p>&lt;strong>Главное — начать.&lt;/strong>&lt;/p></content></item></channel></rss>